#+TITLE: GNU Emacs configuration file
#+AUTHOR: Joan Domingo Pasarin
#+EMAIL: jdomingopasarin@icloud.com
#+OPTIONS: toc:nil
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))
#+MACRO: emacs-development-version (eval (substring (emacs-version) 0 14))

+ Created: 2021-03-22
+ Updated: *{{{export-date}}}*.
+ Emacs Version: {{{emacs-development-version}}}
+ File history:
  [[https://github.com/jdominpa/dotfiles/commits/master/stow/emacs/.emacs.d]].

#+TOC: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: overview
:END:

** Links to this document
:PROPERTIES:
:CUSTOM_ID: links
:END:

+ Git repository :: [[https://github.com/jdominpa/dotfiles]]

** What is this document
:PROPERTIES:
:CUSTOM_ID: what_is_this_document
:END:

This document, referred to in the source code version as =emacs.org=,
contains all of my configurations for GNU Emacs.  When I started using
Emacs I created a structure of =.el= files stored in various
directories inside =.emacs.d= an used =init.el= to load all of them.
Since the creation of this document I've started using a literate
configuration which follows the principles of "literate programming":
a combination of ordinary text and inline code blocks.  Emacs then
parses this file to proper =.el= files evaluating only the Elisp
("Emacs Lisp") parts.  The rest of the text is there to explain the
underlying rationale of the configuration.

The advantatge of using literate programming is that we can document
the code exhaustively in a way that couldn't be achievable with a
regular code file.  Not only can we use typography to its full
potential, but we can also use techniques such as links between
sections and URLs.

In more practical terms, this file is an =org-mode= file.  It's
divided in sections and each section provides information about the
configuration it contains.

Finally, I would like to make notice that a lot of this configuration
is inspired (or copied directly from) by [[https://protesilaos.com/dotemacs/][Protesilaos Stavrou
configuration]] also done in Org.  If you check his configuration files
you'll find many similarities with this configuration.  If you want to
learn about Emacs, politics and philosophy definetly check out his
[[https://www.youtube.com/channel/UC0uTPqBCFIpZxlz_Lv1tk_g][youtube channel]] and his [[https://protesilaos.com/][website]] (check other people's Emacs work in
[[#other_people_emacs_work][this section]]).

*** Contents of init.el
:PROPERTIES:
:CUSTOM_ID: contents_init
:END:

The =emacs.org= file is loaded from another file, named =init.el= per
the Emacs conventions. Mine sets up package archives, installs
=use-package= and loads this org file.

Before Emacs version 27.1 package initialization had to be done in
=init.el= by means of calling =package-initialize=. However, v27.1
introduced the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][=early-init.el=]] file which gets loaded before
=init.el=. In that version and any later ones package initialization
is enabled by default and done after loading =early-init.el= but
before loading =init.el=. Hence, calling =package-initialize= is no
longer needed.

You will find that after defining package archives =init.el= installs
=use-package=. [[https://github.com/jwiegley/use-package][Use-package]] is a macro used to organize and isolate
package configuration in Emacs in a clean and performance-oriented
way. Although use-package is not intended to be a package manager, it
has some useful funcionality to interface with package managers. In
this configuration I use the keyword =:ensure= to install any
uninstalled external packages at startup.

Finally, =init.el= (see below) also sets some variables and provides a
couple of functions that control the startup and closing of my Emacs
sessions.

+ =jdp-emacs-build-config= is a function that runs before closing
  Emacs' session. It regenerates my configuration and byte compiles
  the output. This helps me make sure that the latest version of my
  setup is always running without slowing the startup process.

+ =jdp-emacs-load-config= will either load the output of the previous
  function or, if it doesn't find that output, parse this document. In
  either case, my configuration gets loaded.

#+include: init.el src emacs-lisp :tangle no

**** The =early-init.el=
:PROPERTIES:
:CUSTOM_ID: early-init
:END:

As I have explained before, starting with Emacs v27.1 and forward, we
can use =early-init.el= can be used to control finer details about
package initialization and some GUI elements. Here is mine:

#+include: early-init.el src emacs-lisp :tangle no

*** About the source code of this document
:PROPERTIES:
:CUSTOM_ID: about_this_document
:END:

The previous source code blocks are not declared as emacs-lisp source
code in the =org-mode= version of this document but rather as
examples, so they can't be parsed by the actual setup.

From this point forward, code blocks are wrapped in =#+begin_src= and
=#+end_src= tags (not visible in the website version of this
page). For Emacs v27.1, these templates can be inserted with the
keybind =C-c C-,=.

In addition, each section has a unique custom id used to reference the
section in other places of the document. There are also normal links
using URLs which can be inserted in Org mode with =C-c C-l=.

** COPYING
:PROPERTIES:
:CUSTOM_ID: copying
:END:

Copyright (c) 2021 Joan Domingo Pasarin <jdomingopasarin@icloud.com>

This file is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 3, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

For a full copy of the GNU General Public License see
[[http://www.gnu.org/licenses/]].

* Base settings
:PROPERTIES:
:CUSTOM_ID: base_settings
:END:

This section contains the configurations that are needed prior to the
setup of everything else.

** Common auxiliary functions (jdp-common.el)
:PROPERTIES:
:CUSTOM_ID: common_auxiliary_functions
:END:

There are a few functions that I use in multiple sections of my Emacs
configuration.  To keep them all together I placed them in a dedicated
=jdp-common.el= file.  All I do here is load the file.

#+begin_src emacs-lisp
  (use-package jdp-common)
#+end_src

Here are the contents of the =jdp-common.el= file:

#+include: jdp-lisp/jdp-common.el src emacs-lisp :tangle no

** Common custom functions (jdp-simple.el)
:PROPERTIES:
:CUSTOM_ID: custom_functions
:END:

=jdp-simple.el= contains my own custom commands that are broadly in
line with the built-in =simple.el= and =lisp.el= libraries.  You can
find the code below to read more about each command.

Since this is a foundational part of my Emacs setup, I decide to also
re-bind and change some keybindings.

#+begin_src emacs-lisp
  (use-package jdp-simple
    :bind (("C-z" . nil)
           ("C-x C-z" . nil)
           ("M-`" . nil)
           ("C-h K" . describe-keymap)
           ;; Commands for lines
           ("C-S-n" . jdp-simple-multi-line-next)
           ("C-S-p" . jdp-simple-multi-line-prev)
           ("M-SPC" . cycle-spacing)
           ("M-o" . delete-blank-lines)
           ;; Commands for text manipulation
           ("M-c" . capitalize-dwim)
           ("M-l" . downcase-dwim)        ; "lower" case
           ("M-u" . upcase-dwim)
           ("C-^" . jdp-simple-reverse-delete-indentation)
           ;; Commands for buffers
           ("C-=" . count-words)))
#+end_src

These are the contents of the =jdp-simple.el= library (the source code
can be found [[https://github.com/jdominpa/dotfiles/blob/master/stow/emacs/.emacs.d/jdp-lisp/jdp-simple.el][here]]).

#+include: jdp-lisp/jdp-simple.el src emacs-lisp :tangle no

** Put customisation settings in a "custom.el" file
:PROPERTIES:
:CUSTOM_ID: customisation_settings
:END:

When a package gets installed or you customize a variable through the
customize interface, Emacs will append Elisp code to your init file.
This can become a source of inconsistencies and thats why I instruct
Emacs to place all the customisation in a =custom.el= file stored in
=.emacs.d= and load it at startup.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

** Custom color theme
:PROPERTIES:
:CUSTOM_ID: color_theme
:END:

These days I use the [[https://protesilaos.com/modus-themes/][Modus Themes]] created by Protesilaos Stavrou (you
can check the repository [[https://gitlab.com/protesilaos/modus-themes/][here]]).  The package is composed of two color
themes which are "Modus Operandi" (light) and "Modus Vivendi" (dark).
To learn more about all the customisation options available you can
check [[https://protesilaos.com/modus-themes/#h:bf1c82f2-46c7-4eb2-ad00-dd11fdd8b53f][this]] section of the Modus Themes website.

#+begin_src emacs-lisp
  (use-package modus-themes
    :ensure t
    :bind ([f5] . modus-themes-toggle)
    :init
    ;; Customisation options
    (setq modus-themes-bold-constructs t
          modus-themes-slanted-constructs t
          modus-themes-mode-line nil)
    ;; Load the theme files before enabling a theme
    (modus-themes-load-themes)
    :config
    (modus-themes-load-vivendi))
#+end_src

** Typeface configurations
:PROPERTIES:
:CUSTOM_ID: typeface_configurations
:END:

I use Emacs to program in various languages and writing a variety of
mathematical related content (notes, articles, university homework,
etc.).  Any font I use has to be readable at both small and large
sizes, have nice bold weights, be equally readable against light and
dark backgrounds, use the =*.ttf= spec and not have a name that
advertises some brand directly.

The section on [[#font_configuration][Font configurations]] defines typefaces that I like and
consider suitable for my needs.

Lastly, on a modern GNU/Linux system that uses =fontconfig=,
user-specific fonts are stored in =~/.local/share/fonts=.

*** Font configurations (jdp-fonts.el)
:PROPERTIES:
:CUSTOM_ID: font_configuration
:END:

I have a set of functions defined in the library =jdp-fonts.el= to
help with typeface configurations.  Here are some important ones:

+ =jdp-fonts-set-fonts= is a command that lets you select with
  completion a predetermined set of font configuration.  This
  predetermined sets can be defined with the variable
  =jdp-fonts-typeface-sets-alist=.

+ =jdp-fonts-fonts-per-monitor= sets the appropriate font family and
  size depending on whether I am using my laptop or my desktop PC.

+ =jdp-fonts-bold-face= allows us to set a list of typefaces
  associated with weights for their "bold" variation.  We can use it
  with fonts that have various weights such as "light", "extrabold",
  "semibold", to control what weight should be used with heavy
  emphasis text.  Note that this only works if your theme uses the
  =bold= face instead of the =:weight bold= property.

#+begin_src emacs-lisp
  (use-package jdp-fonts
    :demand t
    :bind ("C-c f" . jdp-fonts-set-fonts-dwim)
    :config
    (setq jdp-fonts-typeface-sets-alist
          '((desktop 140 "Iosevka" normal "Inter" normal)
            (reader 170 "Iosevka" light "FiraGO" normal)
            (presentation 180 "Fira Code" light "FiraGO" normal)))
    (setq jdp-fonts-monospaced-list
          '("Hack" "DejaVu Sans Mono" "Iosevka" "Source Code Pro"
            "Ubuntu Mono" "Fantasque Sans Mono" "Fira Code" "Monoid"))
    (setq jdp-fonts-heights-list
          (number-sequence 100 200 5))
    (setq jdp-fonts-line-spacing-alist
          '(("Ubuntu Mono" . 2)))
    (setq jdp-fonts-laptop-desktop-keys-list '(laptop desktop)
          jdp-fonts-max-small-resolution-width 1440)
    (setq jdp-fonts-bold-weight-alist
          '(("Iosevka" . semibold)
            ("Fira Code" . semibold)
            ("Source Code Pro" . semibold)))

    ;; This is defined in Emacs' C code, though I feel this is a good
    ;; place to put it.
    (setq x-underline-at-descent-line t)

    ;; And this just sets the right font depending on whether my laptop is
    ;; connected to an external monitor or not.
    (jdp-fonts-fonts-per-monitor)
    (add-hook 'jdp-fonts-set-typeface-hook #'jdp-fonts-line-spacing)
    (add-hook 'jdp-fonts-set-typeface-hook #'jdp-fonts-bold-face)

    ;; See theme section for this hook
    (add-hook 'modus-themes-after-load-theme-hook #'jdp-fonts-bold-face))
#+end_src

Here is the source code of =jdp-fonts.el=.

#+include: jdp-lisp/jdp-fonts.el src emacs-lisp :tangle no

*** Simple font suitability test
:PROPERTIES:
:CUSTOM_ID: font_test
:END:

Here is a simple test to make an initial assessment of the overall
quality of a monospaced font: /can you discern the characters at a
quick glance?/ If you can, the typeface passes the test, otherwise
search another one.

Note that obviously this test isn not scientific and perfect in any
way, but it is a good place to start.

#+begin_example
()[]{}<>«»
6bB8&
0ODdoaoOQGC
I1tilIJL|
!¡ij
5$§SsS5
17ZzZ2
9gqpG6
hnmMN
uvvwWuuwvy
x×X
.,·°%
¡!¿?
:;
`''"‘’“”
-~≈=≠+*_
…⋯
...

Sample character set
Check for monospacing and Greek glyphs

ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
~!@#$%^&*+
`'"‘’“”.,;:…
()[]{}-_=|<>/\
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
αβγδεζηθικλμνξοπρστυφχψω

// NOTE that I got this from Hack's website:
// https://source-foundry.github.io/Hack/font-specimen.html
//  The four boxing wizards jump
#include <stdio.h> // <= quickly.
int main(int argc, char **argv) {
  long il1[]={1-2/3.4,5+6==7/8};
  int OxFaced=0xBAD||"[{(CQUINE";
  unsigned O0,l1,Z2,S5,G6,B8__XY;
  printf("@$Hamburgefo%c`",'\n');
  return ~7&8^9?0:l1|!"j->k+=*w";
}
#+end_example

*** Bidirectional writing and =so-long.el=
:PROPERTIES:
:CUSTOM_ID: bidirectional_writing
:END:

By default Emacs supports bidirectional writing.  I only write/read in
Latin alphabets therefore, I set the default directionality to what my
languages use which can improve the responsiveness of Emacs in some
cases.

Good performance is the reason to also enable =global-so-long-mode=,
built into Emacs versions >= 27, which allows the active major mode to
adapt buffers with very long lines.  What "very long" means can be
customized if you want with =M-x find-library so-long=.

The code below is a variation of the one found in Alain M. Lafon in
the [[https://200ok.ch/posts/2020-09-29_comprehensive_guide_on_handling_long_lines_in_emacs.html][Comprehensive guide on handling long lines in Emacs]] (2020-09-29).

#+begin_src emacs-lisp
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq bidi-inhibit-bpa t)

  (use-package so-long
    :config
    (global-so-long-mode))
#+end_src

** Multiple cursors (multiple-cursors)
:PROPERTIES:
:CUSTOM_ID: multiple_cursors
:END:

=multiple-cursors= is a package that allows us to edit multiple places
in the buffer at the same time.  It works as follows:

1. You select a region of text.
2. You then use one of the functions the package provides to create an
   extra cursor in the next place in the buffer that matches your
   selected region (you can repeat this step as many times as you
   want).
3. You can now edit both regions at the same time using the "multiple
   cursors".
4. When you finish you can delete all the extra cursors with =RET= or
   =C-g=.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind (("C-." . mc/mark-next-like-this)
           ("C-," . mc/mark-previous-like-this)
           ("C->" . mc/skip-to-next-like-this)
           ("C-<" . mc/skip-to-previous-like-this)
           ("C-c C->" . mc/mark-all-like-this)))
#+end_src

** Key chord hints (which-key)
:PROPERTIES:
:CUSTOM_ID: key_chord_hints
:END:

I install =which-key= to display hints of possible tails of a key
chord.  However, I don't like the hint popup to show up almost
instantly so I set a high idle delay.  I also do that because you can
follow up any key chord with =C-h= to produce a help buffer with all
the possible tails of the key chord.

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (setq which-key-show-early-on-C-h nil
          which-key-idle-delay 1.25)
    (which-key-mode))
#+end_src

** Asynchronous facilities
:PROPERTIES:
:CUSTOM_ID: async_facilities
:END:

This package provides some asynchronous processing facilities for
various Emacs interfaces such as dired's copy and rename operations
(also read [[#dired][Dired (directory editor, file manager)]]).

All we need here is to just load the feature.

#+begin_src emacs-lisp
  (use-package async
    :ensure t
    :defer t)
#+end_src

* Selection candidates and search methods
:PROPERTIES:
:CUSTOM_ID: selection_candidates
:END:

** Completion framework and extras
:PROPERTIES:
:CUSTOM_ID: completion_and_extras
:END:

The way I use Emacs is through searching and narrowing selection
candidates.  To put it in another way, we spend less time worrying
about where things are and more on how quickly can w bring them to
focus.

*** Orderless completion style (jdp-orderless.el)
:PROPERTIES:
:CUSTOM_ID: orderless_completion
:END:

The /sublime/ [[https://github.com/oantolin/orderless][=orderless= package]] is developed by Omar Antolín
Camarena.  It provides an efficient, out-of-order grouped pattern
matching completion style.  It works by dividing the written pattern
in the minibuffer into space-separated components and matches
candidates that match the components in any order (i.e. "orderless").
The components can be matched using various styles such as regexp,
literal, flex, initialism, etc.  Beign an Emacs package, you can
customize the delimiters used to determine components and the styles
used for the patter matching.

In this section I set up =orderless=.  The =orderless= completion
style is appended to the minibuffer's customisation options for
=completion-styles= in the section [[#minibuffer_and_extras][Minibuffer configuration and
extras]].

The file =jdp-orderless.el= contains some small changes that I make.
It defines three style dispatchers which are single characters that
set a style for a particular component when appended to that
component:

+ With the equals sign appended to a sequence of characters, we call
  =jdp-orderless-literal-dispatcher= which instructs orderless to
  match that sequence as a literal string.

+ With a comma appended to a sequence of characters, we call
  =jdp-orderless-initialism-dispatcher= which instructs orderless to
  match that sequence as a initialism string.

+ With the tilda sign appended to a sequence of characters, we call
  =jdp-orderless-flex-dispatcher= which instructs orderless to match
  that sequence as a flex string.

#+begin_src emacs-lisp
  (use-package jdp-orderless
    :config
    (setq jdp-orderless-default-styles
          '(orderless-prefixes
            orderless-strict-leading-initialism
            orderless-regexp))
    (setq jdp-orderless-alternative-styles
          '(orderless-literal
            orderless-prefixes
            orderless-strict-leading-initialism
            orderless-regexp)))

  (use-package orderless
    :ensure t
    :bind (:map minibuffer-local-completion-map
                ("?" . nil)
                ("SPC" . nil))
    :config
    (setq orderless-matching-styles jdp-orderless-default-styles)
    (setq orderless-style-dispatchers
          '(jdp-orderless-flex-dispatcher
            jdp-orderless-literal-dispatcher
            jdp-orderless-initialism-dispatcher)))
#+end_src

Here are the contents of the =jdp-orderless.el= library:

#+include: jdp-lisp/jdp-orderless.el src emacs-lisp :tangle no

*** Completion annotations (marginalia)
:PROPERTIES:
:CUSTOM_ID: completion_annotations
:END:

Marginalia is a package developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates.  It works
with Selectrum, Icomplete vertical, Embark's completions buffer and the
default completions' buffer.

#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :config
    (marginalia-mode))
#+end_src

*** Minibuffer configurations and extras (vertico)
:PROPERTIES:
:CUSTOM_ID: minibuffer_and_extras
:END:

The minibuffer is the epicentre of interactivity with all sorts of
Emacs workflows: selecting buffers, opening files, providing answers
to prompts, etc.  Emacs has the following built-in capabilities to
perform these interactions:

+ Narrowing :: Use pattern matching to filter a list of choices.  In
  addition to the built-in matching styles there are also external
  packages that extend the existing ones like Orderless (see [[#orderless_completion][Orderless
  completion style (jdp-orderless.el)]])

+ Selecting :: Visualise the list of possible completions and pick one
  of them using regular motions.  By default, Emacs displays the
  results in a special =*Completions*= buffer which does not have a
  lot of features.

There are third party completion frameworks that do the aforementioned
like Ivy and Helm.  Others like Selectrum and the built-in Icomplete
focus on the latter.  At the moment I am using =vertico= which
provides a preformant and minimalistic vertical completion UI based on
the Emacs' default completion system.

Finally, here is an overview of the settings covered:

+ Completion styles :: As seen in the [[#orderless_completion][Orderless completion style]]
  section, I use orderless for completion in general.  I also add the
  =partial-completion= style which makes it so that =~/.l/s/f= expands
  to =~/.local/share/fonts= for example.

+ Recursive minibuffers :: With recursive minibuffers enabled you can
  create multiple minibuffers even when there are already some active.
  To exit all of them at once you can hit the =C-]= to call
  =abort-recursive-edit= (the usual =C-g= also works).

  The =minibuffer-depth-indicate-mode= will show a depth indicator
  represented as a number next to the minibuffer prompt if a recursive
  edit is in progress.

#+begin_src emacs-lisp
  (use-package minibuffer
    :demand t
    :hook (completion-list-mode . jdp-common-truncate-lines-silently) ; from `jdp-common.el'
    :config
    (setq completion-styles '(orderless partial-completion)
          completion-category-defaults nil
          completion-category-overrides nil
          completion-cycle-threshold nil
          completion-show-help nil
          completion-auto-help t
          completion-ignore-case t)
    (setq completions-format 'one-column
          completions-detailed t)
    (setq read-buffer-completion-ignore-case t
          read-file-name-completion-ignore-case t)
    (setq enable-recursive-minibuffers t
          read-answer-short t)
    (setq resize-mini-windows t)
    (setq minibuffer-eldef-shorten-default t)
    (file-name-shadow-mode)
    (minibuffer-depth-indicate-mode)
    (minibuffer-electric-default-mode))

  (use-package vertico
    :ensure t
    :config
    (vertico-mode))

  (use-package vertico-reverse
    :after vertico
    :config
    (vertico-reverse-mode))
#+end_src

*** Enhanced minibuffer commands (consult)
:PROPERTIES:
:CUSTOM_ID: enhanced_minibuffer_commands
:END:

Consult is a package developed by Daniel Mendler which works with the
standard minibuffer completion system and other interfaces like
Icomplete and Selectrum.

Consult offers minibuffer-centric commands that either enhance already
existing commands or provides new ones entirely.

Some Consult commands are straight drop-in improvements for built-in
ones.  For example =consult-complex-command= is and interactive
improved version of the =repeat-complex-command=.  The same thing
happens with the =goto-line= command.

Other commands enhance the defaults with a filtering mechanism.  An
example would be =consult-imenu= which recognises syntactic constructs
that are variables, functions and macros.

This package has a filtering mechanism internally known as narrowing
which can be accessed with a keybinding for all commands that support
it.  The key is configured with the variable =consult-narrow-key=
which I have set to =>=.  The way the system works is the following:
you type the narrowing key followed by another key that specifies the
targets that we want to match.  These narrowing conditions can be
removed at any time by hitting backspace.

The narrowing-by-type system can be used without the narrowing key
also.  Typing the type specific character will activate the filter
without needing to input the =consult-narrow-key=.

Consult also has various commands that call asynchronously external
processes such as =grep= or =find=.  Not only are the external
commands called in an asynchronous way but they also implement a
two-stage input scheme:

+ First you type a pattern which will be passed to the external
  program.  This triggers the asynchronous call and our input looks
  like =#PATTERN= at this point.

+ You can then type another field delimiter (by default =#=) which
  will instruct Consult to keep the results that =#PATTERN= found and
  use Emacs' own mechanisms to further narrow the list.  At this point
  our input will look like =#PATTERNS#MORE-PATTERNS= where
  =#MORE-PATTERNS= will use the Emacs' completion style.

By default, certain Consult commands show previews which I find to be
distracting.  Hence, I disable preview entirely.

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind (("C-x M-:" . consult-complex-command)
           ("C-x M-m" . consult-minor-mode-menu)
           ("C-x M-k" . consult-kmacro)
           ("M-y" . consult-yank-pop)
           ("M-K" . consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
           ("M-F" . consult-focus-lines)
           ("M-g g" . consult-goto-line)
           ("M-g M-g" . consult-goto-line)
           ("M-g m" . consult-mark)
           ("M-g i" . consult-imenu)
           ("M-g o" . consult-outline)
           ("M-s g" . consult-grep)
           :map consult-narrow-map
           ("?" . consult-narrow-help))
    :config
    (setq register-preview-delay 0.8
          register-preview-function #'consult-register-format)
    (setq consult-preview-key nil ; disable previews
          consult-narrow-key ">"))

  (use-package consult-flycheck
    :ensure t
    :bind (:map flycheck-command-map
                ("!" . consult-flycheck)))
#+end_src

*** Projects
:PROPERTIES:
:CUSTOM_ID: projects
:END:

Starting with Emacs 28, =project.el= contains lots of interesting
additions that make it an all-round useful tool. Some of them are a
new prefix key bound to =C-x p=. This has good mnemonic value, like
those for tabs (=C-x t=) and registers (=C-x r=).

A project is a version controlled directory governed by some program.
Nowadays that program is usually =git= though there are other backends
supported.

Using any of the commands listed in =C-x p C-h= will append the
current project to a list of "known projects", stored in the
dynamically updated =project--list= variable, whose contents are
stored in a file defined by =project-list-file=. It is then possible
to switch between your projects and proceed to immediately perform an
action on them with =C-x p p=. A menu with possible commands will
appear once you select a project. That is customisable via
=project-switch-commands=.

=C-x p p= (=project-switch-project=) can also be used to store a new
version-controlled directory in the =project--list= through the
=... (choose a dir)= option.

Here is an overview of the =jdp-project.el= commands:

+ =jdp-project-commit-log= produces a list of the most recent commits
  in the project.  The length of the list can be configured with the
  =jdp-project-commit-log-limit= variable.  If there is no project to
  act upon, the command will prompt for one with completion against
  the project list.

+ =jdp-project-retrieve-tag= lets us switch to an earlier tagged
  commit or branch using completion.  As with the previous command,
  when no project is present, it asks for one before doing its work.

#+begin_src emacs-lisp
  (use-package jdp-project
    :bind (("C-x p l" . jdp-project-commit-log)
           ("C-x p t" . jdp-project-retrieve-tag))
    :config
    (setq jdp-project-commit-log-limit 25))
#+end_src

This is the =jdp-project.el= file:

#+include: jdp-lisp/jdp-project.el src emacs-lisp :tangle no

*** Completion for recent files and directories with recentf
:PROPERTIES:
:CUSTOM_ID: completion_recentf
:END:

=recentf= is a built-in minor mode that keeps track of recently
visited files allowing us to revisit them faster.

#+begin_src emacs-lisp
  (use-package recentf
    :bind ("C-x C-r" . recentf-open-files)
    :config
    (setq recentf-exclude '("/tmp/" "/ssh:" ".gz" ".xz" ".zip")
          recentf-save-file (expand-file-name "recentf" user-emacs-directory))
    (recentf-mode))
#+end_src

*** In-buffer completions (corfu)
:PROPERTIES:
:CUSTOM_ID: in_buffer_completions
:END:

[[https://github.com/minad/corfu][=corfu=]] is a package developed by Daniel Mendler (author of =consult=
and several others) which focuses on text expansion within the buffer.
Its UI involves the typical pop-up window that shows the completion
candidates for the text before the point.  We can then use =C-n= and
=C-p= to cycle through these candidates and select the one we want and
exit with =RET=.  =TAB= can also be used and it will try to complete
as much as possible and only exit if there is a unique match.  Also,
=M-h= and =M-g= can be used to show documentation of the currently
selected candidate.

I also install the [[https://github.com/minad/cape][=cape=]] package, also by Daniel, which adds some
backends to =corfu=.

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :config
    (corfu-global-mode))

  (use-package cape
    :ensure t
    :config
    (dolist (backend '(cape-keyword cape-file cape-dabbrev))
      (add-to-list 'completion-at-point-functions backend)))
#+end_src

** Configurations for built-in search commands
:PROPERTIES:
:CUSTOM_ID: built-in_search
:END:

*** Isearch, occur, grep and extras (jdp-search.el)
:PROPERTIES:
:CUSTOM_ID: isearch_and_extras
:END:

The built-in search mechanisms defined in the libraries =isearch.el=
and =replace.el= are minimal in their presentation, yet they have
powerful applications.  These are the main points of entry to the
commands they offer:

+ =isearch-forward= (=C-s=) prompts for a string and searches the
  buffer for the string incrementally with live feedback on its
  progress.  =isearch-backward= (=C-r=) moves in the opposite
  direction.

  - Two distinct keys may seem redundant at first, but you really
    appreciate this level of precision when recording keyboard macros.
    
  - Use =C-M-s= and =C-M-r= for running a search against a regular
    expression, or call =isearch-toggle-regexp= (=M-r=) after starting
    a regular isearch.

+ =query-replace= (=M-%=) replaces all matches of a string and asks
  you for confirmation on each of them.  If you check its help page
  (press =?= after invoking the command), you will learn that =!=
  stands for an affirmative answer to all, which is a standard in all
  such prompts.

  - =query-replace-regexp= (=C-M-%=) does the same for regular
    expressions.

+ =occur= (=M-s o=) places all matches of a regular expression or
  string in a dedicated buffer.  That can function as an index for
  moving to the relevant points in the buffer, but also as a means of
  refactoring all matches at once.  Just make the =*Occur*= buffer
  editable with =e=.  Running =occur= with a numeric argument provides
  N lines of context around the given match.

The beauty of the Occur and Replace commands is that they can be
initiated from within an active Isearch session, using the same keys.
So =C-s INPUT M-s o= will search for input and then run =occur= on it.
Try =C-h k C-s= to get a help menu with all the extra keys you can use
with =isearch=.  These are the ones I use the most:

| Key chord | Description                  |
|-----------+------------------------------|
| C-s C-w   | Search char or word at point |
| M-s .     | Search for symbol at point   |
| M-s o     | Run `occur' on regexp        |
| M-s h r   | Highlight regexp             |
| M-s h u   | Undo the highlight           |
| C-s M-r   | Toggle regexp search         |
| M-%       | Run `query-replace'          |
| C-M-%     | `query-replace-regexp'       |

Every one of the above, except the first item, can be executed on
their own, or as extensions of =C-s= (and variants).

The Occur and Replace operations are aware of the active region which
means that if you highlight, say, a paragraph and do =M-%= you will
only replace matches inside of that area (while not relevant to our
point, this also works for =undo= (=C-/=), which is super useful).

Moving on to my own configuration, here is my setup for these built-in
tools:

#+begin_src emacs-lisp
  (use-package isearch
    :bind (:map minibuffer-local-isearch-map
           ("M-/" . isearch-complete-edit)
           :map isearch-mode-map
           ("C-g" . isearch-cancel)
           ("M-/" . isearch-complete))
    :config
    (setq search-whitespace-regexp ".*?"
          isearch-lax-whitespace t
          isearch-regexp-lax-whitespace nil)
    (setq search-highlight t
          isearch-lazy-highlight t
          isearch-lazy-count t
          lazy-count-prefix-format nil
          lazy-count-suffix-format " (%s/%s)")
    (setq isearch-yank-on-move 'shift))

  (use-package replace
    :hook ((occur-mode . hl-line-mode)
           (occur-mode . jdp-common-truncate-lines-silently))
    :bind (("M-s M-o" . multi-occur)
           :map occur-mode-map
           ("t" . toggle-truncate-lines)))

  (use-package grep
    :commands (grep grep-find grep-find-toggle-abbreviation))

  (use-package jdp-search
    :bind (:map isearch-mode-map
           ("<backspace>" . jdp-search-isearch-abort-dwim)
           ("<C-return>" . jdp-search-isearch-other-end)))
#+end_src

Here is the contents of =jdp-search.el=:

#+include: jdp-lisp/jdp-search.el src emacs-lisp :tangle no

*** =wgrep= (writable grep)
:PROPERTIES:
:CUSTOM_ID: wgrep
:END:

=wgrep= allows us to make a grep buffer writable and save the changes
to all affected buffers.  Technically this is the same as using the
built-in =occur=.  In the source code below you will see that I use
the same keys defined for editing in =occur= by default to edit the
grep buffer with =wgrep=.

#+begin_src emacs-lisp
  (use-package wgrep
    :ensure t
    :bind (:map grep-mode-map
                ("e" . #'wgrep-change-to-wgrep-mode)
                ("C-x C-q" . #'wgrep-change-to-wgrep-mode)
                ("C-c C-c" . #'wgrep-finish-edit)))
#+end_src

* Directory, buffer and window management
:PROPERTIES:
:CUSTOM_ID: directory_buffer_window
:END:

** Dired (directory editor, file manager)
:PROPERTIES:
:CUSTOM_ID: dired
:END:

The directory editor abbreviated as "Dired" is a built-in directory
and file manager.  You can use it to interactively create, delete,
copy or rename files and directories, etc.  Here is a list of settings
and configurations that I use in dired:

+ Don't prompt when deleting or copying recursively.

+ Send deletions to the system's Trash.  This is safer than the
  standard =rm= since it allows us to recover deleted files.

+ Reformat output.  Sort directories first, show dotfiles, omit
  implicit directories and use human-readable size units.

+ Hide all the details by default (permissions, size, etc.).  You can
  toggle them back on by pressing =(=.  Enable =hl-line-mode= to make
  it easier to spot the current item.

+ While having two dired buffers open, the rename and copy operations
  will place the path of the inactive one as the target destination.
  When multiple dired buffers are present, this works between the
  current and most recently used ones.

Here is also a list of packages that I use with Dired:

+ Dired subtree :: This third-party package offers tree-style
  navigation, meaning that the subdirectories of the current Dired
  buffer can be expanded and contracted in place.  It is possible to
  perform the same kind of folding on their subdirectories, and so on.
+ Dired extras (dired-x.el) :: These is built-in package which offers
  some additional Dired features.  The one I use the most is
  =dired-jump= which will take you to the directory that contains the
  current buffer.

#+begin_src emacs-lisp
  (use-package dired
    :hook ((dired-mode . dired-hide-details-mode)
           (dired-mode . hl-line-mode))
    :config
    (setq dired-recursive-copies 'always
          dired-recursive-deletes 'always)
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
          "-AXhlv --group-directories-first")
    (setq dired-dwim-target t))

  (use-package dired-aux
    :config
    (setq dired-isearch-filenames 'dwim
          dired-create-destination-dirs 'ask))

  (use-package dired-x
    :bind (("C-x C-j" . dired-jump)
           ("C-x 4 C-j" . dired-jump-other-window))
    :config
    (setq dired-clean-up-buffers-too t
          dired-clean-confirm-killing-deleted-buffers t))

  (use-package dired-subtree
    :ensure t
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)
                ("<C-tab>" . dired-subtree-cycle)))

  ;; Part of the `async' package.
  (use-package dired-async
    :hook (dired-mode . dired-async-mode))
#+end_src

** Buffer management
:PROPERTIES:
:CUSTOM_ID: buffer_management
:END:

*** Unique buffer naming
:PROPERTIES:
:CUSTOM_ID: unique_buffer_naming
:END:

Uniquify is a library that has some useful utilities to make working
with multiple buffers easier.  When two buffers with the same name are
open, Emacs will desambiguate their names by displaying the element of
differentiation in accordance with =uniquify-buffer-name-style= while
=uniquify-strip-common-suffix= will remove the part of the file system
path they have in common.

These operations are reversed when one of the buffers is removed an
there is no more chance of ambiguity.

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward
        uniquify-strip-common-suffix t
        uniquify-after-kill-buffer-p t)
#+end_src

*** Ibuffer and extras
:PROPERTIES:
:CUSTOM_ID: ibuffer
:END:

Ibuffer is a built-in package that serves as a drop-in replacement for
=list-buffers=.  It offers granular control over the buffer list and
is more powerful overall.  Hence, I bind it to =C-x C-b=.

Here are the configurations I make to =ibuffer=:

+ Prompt for confirmation only when deleting a modified buffer.
+ Do not open on the other window; use the current one.
+ Do not show empty filter groups.

#+begin_src emacs-lisp
  (use-package ibuffer
    :hook ((ibuffer . ibuffer-set-up-preferred-filters)
           (ibuffer . hl-line-mode))
    :bind ("C-x C-b" . ibuffer)
    :config
    (setq ibuffer-expert t
          ibuffer-display-summary nil
          ibuffer-use-other-window nil
          ibuffer-show-empty-filter-groups nil
          ibuffer-movement-cycle nil
          ibuffer-use-header-line t
          ibuffer-default-shrink-to-minimum-size nil
          ibuffer-saved-filter-groups nil
          ibuffer-old-time 48))
#+end_src

** Window configuration
:PROPERTIES:
:CUSTOM_ID: window_configuration
:END:

A few years ago, before I started using Emacs, I used to use a tiling
window manager.  This type of window managers try to display all open
windows on the screen while making sure that they are not overlaping
and all screen space is used.  Initially I thought this was a great
way of displaying and managing windows but after some time, I came to
the conclusion that it is flawed.  The available space on any screen
is finite and the tiling system becomes inefficient at scale.  Even if
you have different workspaces (most tiling window managers have them),
I found that the system becomes cumbersome to use.

After I started using Emacs, I found that a better way to manage
buffers (or windows in the case of a desktop) is to use search methods
with filtering and narrowing mechanisms to bring to the surface what
we need at any time.  This removes the need to know where things are
placed and the restriction of finite space.

Having said that, Emacs also has multiplexing capabilities by means of
setting window rules, using directional window navigation keys and
recording history and layouts.

*** Window rules and basic tweaks
:PROPERTIES:
:CUSTOM_ID: window_rules
:END:

In this section I set some keybinds related to adjusting window size.
They are the following:

+ =balance-windows= adjusts all windows so that they have the same
  size.
+ =fit-window-to-buffer= adjusts the selected window to display its
  buffer's contents exactly.
+ =balance-windows-area= makes all visible windows the same area
  approximately.
+ =enlarge-window= and =shrink-window= increase or decrease the
  height of the window respectively.
+ =enlarge-window-horizontally= and =shrink-window-horizontally=
  increase or decrease the width of the window respectively

#+begin_src emacs-lisp
  (use-package window
    :demand t
    :bind (("C-x _" . balance-windows)
           ("C-x -" . fit-window-to-buffer)
           ("C-x +" . balance-windows-area)
           ("C-x }" . enlarge-window)
           ("C-x {" . shrink-window)
           ("C-x >" . enlarge-window-horizontally) ; override `scroll-right'
           ("C-x <" . shrink-window-horizontally)  ; override `scroll-left'
           :map resize-window-repeat-map
           (">" . enlarge-window-horizontally)
           ("<" . shrink-window-horizontally))
    :config
    (setq window-combination-resize t
          window-sides-vertical nil
          switch-to-buffer-in-dedicated-window 'pop))
#+end_src

*** Window history (winner-mode)
:PROPERTIES:
:CUSTOM_ID: window_history
:END:

Winner is a built-in tool that keeps a record of buffer and window
layout changes. It then allows us to move back and forth in the
history of said changes. I have it enabled by default and I assign its
two main functions to =C-M-<left>= and =C-M-<right>=.

Also check: [[#directional_window_motions][Directional window motions (windmove)]]

#+begin_src emacs-lisp
  (use-package winner
    :demand t
    :bind (("M-p" . winner-undo)
           ("M-n" . winner-redo))
    :config
    (winner-mode))
#+end_src

*** Switching windows (ace-window)
:PROPERTIES:
:CUSTOM_ID: switching_windows
:END:

=ace-window= is a package that improves the process of switching
between open windows.  It offers the command =ace-window= which
extends the functionality of the built-in =other-window= command in
the following way:

1. If there are only two windows on display, =ace-window= will behave
   like the regular =other-window= command.

2. If there are three or more windows on display, =ace-window= will
   show a highlighted character on each window.  Pressing one of these
   characters will switch to the corresponding window and finish the
   command.

See also: [[#window_history][Window history (winner-mode)]]

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :bind ("C-x o" . ace-window)
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src

* Applications and utilities
:PROPERTIES:
:CUSTOM_ID: applications_utilities
:END:

Configuration for everything that would normally be a standalone
application or utility.

** Version control tools
:PROPERTIES:
:CUSTOM_ID: version_control
:END:

I use Magit for any /git related/ task.  Magit offers a modal
interface which organizes all the common /git/ commands in sets of
keys that can be pressed without any modifiers.

Inside a =magit-status= buffer you can press the =?= key to see a
transient menu with all the possible key presses and their associated
commands.  This extends to any other Magit buffer, i.e. you can press
=?= in any Magit buffer to see a menu with all available commands.

Magit has great defaults and should work out of the box in general. I
use the =C-c g= key to call =magit-status= at any moment.  In
addition, I install the magit-todos package which displays TODOs found
in the git repository in the =magit-status= buffer.

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :hook (git-commit-mode . goto-address-mode)
    :bind ("C-c g" . magit-status)
    :config
    (setq magit-diff-refine-hunk t))

  (use-package magit-todos
    :ensure t
    :hook (magit-status-mode . magit-todos-mode))
#+end_src

** Eshell
:PROPERTIES:
:CUSTOM_ID: eshell
:END:

Emacs can act as both a /terminal emulator for command line shells/
and a /toolkit for terminal emulators/.  The following section covers
only the first one as I don not use the likes of =ansi-term= or
=vterm=.

Eshell is a command prompt written entirely in Elisp.  This comes with
its pros and cons: it can understand Elisp and behaves almost like
Unix shells like Bash but there are certain differences such as
specific commands that are not the same.  Another con is that Eshell
can not display pseudo graphical programs like =mutt=, =htop=,
=ncmpcpp= and so on.

In my case, I find Eshell to be enough to do everything I need a
command line for.

#+begin_src emacs-lisp
  (use-package eshell
    :config
    (setq eshell-cd-on-directory t
          eshell-hist-ignoredups t
          eshell-save-history-on-exit t
          eshell-scroll-to-bottom-on-input t)
    (setq eshell-directory-name
          (expand-file-name "eshell" user-emacs-directory))
    (setq eshell-aliases-file
          (expand-file-name "eshell/alias" user-emacs-directory))
    (setq password-cache t
          password-cache-expiry 600))
#+end_src

** Org-mode
:PROPERTIES:
:CUSTOM_ID: org_mode
:END:

Org is a markup language similar to Markdown.  We use symbols to
indicate the meaning of a construct and its context, such as a
headline or a table.

The real power of Org is that everything is built-in and integrate in
Emacs.  A set of integrated libraries and an extensive ecosystem makes
working with Org extremely easy and fun to do.  For example, as
explained in the section [[#what_is_this_document][What is this document]], this document is
written in =org-mode= and we use =org-babel-tangle= to output the
source blocks to a =.el= file.  In addition, we can export the
document to an HTML or pdf equivalent whenever we find the need for
it.

#+begin_src emacs-lisp
  (use-package org
    :hook ((org-mode . org-indent-mode)
           (org-mode . auto-fill-mode))
    :config
    (setq org-adapt-indentation nil
          org-catch-invisible-edits 'show)
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp")))
#+end_src

** Extensions for PDFs (pdf-tools)
:PROPERTIES:
:CUSTOM_ID: pdf_extensions
:END:

The =pdf-tools= package builds on top of the external libraries
=poppler= and =imagemagick= to deliver a set of minor modes for
reading and interacting with PDF files.

All we need to start reading PDFs is to put the =pdf-loader-install=
function in our configurations which will load the tools once we open
an appropriate file.  The keybind =C-h m= can be used to consult the
key bindings of a PDF buffer.  These are the basic ones:

| Key   | Effect            |
|-------+-------------------|
| +     | Enlarge (zoom in) |
| -     | Shrink (zoom out) |
| 0     | Reset zoom        |
| C-n   | Next line         |
| C-p   | Previous line     |
| SPC   | Scroll down       |
| S-SPC | Scroll up         |

To see which minor modes out of the entire suite are activated we can
use the variable =pdf-tools-enabled-modes=.  One of the minor modes I
use is the =pdf-sync-minor-mode= which syncs the PDF with its
corresponding TeX file when we are using a setup that compiles the
latter to the former.

The value of =pdf-tools= is that it integrates with =isearch= and
=occur= to easily search through the file and produce a buffer of
locations with matching queries.  These facilities are implemented as
the minor modes =pdf-isearch-minor-mode= and
=pdf-occur-global-minor-mode=.

Another helpful integration is with Emacs' =outline-mode= and =imenu=
with the minor mode =pdf-outline-minor-mode=.  Hitting =o= while
viewing a PDF will produce an outline of the document which can be
navigated with =M-x imenu= using minibuffer completion.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :config
    (setq pdf-view-display-size 'fit-height
          pdf-view-continuous t)

    ;; Those functions and hooks are adapted from the manual of my
    ;; modus-themes.  The idea is to (i) add a backdrop that is distinct
    ;; from the background of the PDF's page and (ii) make pdf-tools adapt
    ;; to theme switching via, e.g., `modus-themes-toggle'.
    (defun contrib/pdf-tools-backdrop ()
      (face-remap-add-relative
       'default
       `(:background ,(modus-themes-color 'bg-alt))))

    (defun contrib/pdf-tools-midnight-mode-toggle ()
      (when (derived-mode-p 'pdf-view-mode)
        (if (eq (car custom-enabled-themes) 'modus-vivendi)
            (pdf-view-midnight-minor-mode 1)
          (pdf-view-midnight-minor-mode -1))
        (contrib/pdf-tools-backdrop)))

    (add-hook 'pdf-tools-enabled-hook
              #'contrib/pdf-tools-midnight-mode-toggle)
    (add-hook 'modus-themes-after-load-theme-hook
              #'contrib/pdf-tools-midnight-mode-toggle)

    (pdf-loader-install))
#+end_src

* General interface
:PROPERTIES:
:CUSTOM_ID: general_interface
:END:

This section contains configurations for all aspects of the Emacs user
interface.

** Go to last change
:PROPERTIES:
:CUSTOM_ID: goto_last_change
:END:

I use the =C-z= binding to go to the last change in the buffer.  The
binding is [[#custom_functions][disabled elsewhere in this document]].

#+begin_src emacs-lisp
  (use-package goto-last-change
    :ensure t
    :bind ("C-z" . goto-last-change))
#+end_src

** Mode line
:PROPERTIES:
:CUSTOM_ID: mode_line
:END:

I used to use external packages like =doom-modeline= to modify the
default Emacs modeline but I have come to the conclusion that the
default one is good enough.

In this section I do some minor tweaks to the modeline mainly, I
change the kmacro minor mode tag to something more meaningful and
switch the position of some elements of the modeline.  I also ensure
that line and column numbers are both shown in the modeline as well as
the current position in the buffer.

#+begin_src emacs-lisp
  (setq line-number-mode t
        column-number-mode t
        size-indication-mode t)

  (setq mode-line-defining-kbd-macro
        (propertize " Macro" 'face 'mode-line-emphasis))

  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  "  "
                  mode-line-position
                  " "
                  mode-line-modes
                  "  "
                  (vc-mode vc-mode)
                  "  "
                  mode-line-misc-info
                  mode-line-end-spaces))
#+end_src

*** Hide modeline "lighters" (minions)
:PROPERTIES:
:CUSTOM_ID: hide_modeline
:END:

Lighters are the tags that indicate active minor modes in the
modeline.  Jonas Bernoulli's package =minions= wraps up all lighters
and hides them behind a character.

#+begin_src emacs-lisp
  (use-package minions
    :ensure t
    :config
    (setq minions-mode-line-lighter ";")
    (setq minions-direct (list 'defining-kbd-macro
                               'flymake-mode))
    (minions-mode))
#+end_src

*** Mode line recursion indicators
:PROPERTIES:
:CUSTOM_ID: modeline_recursion_indicators
:END:

Currently trying this package

#+begin_src emacs-lisp
  (use-package recursion-indicator
    :ensure t
    :config
    (setq recursion-indicator-general "&"
          recursion-indicator-minibuffer "@")
    (recursion-indicator-mode))
#+end_src

*** Battery status
:PROPERTIES:
:CUSTOM_ID: battery_status
:END:

Emacs has a built-in library for displaying battery status.  When I
use Emacs in a laptop I usually have it in fullscreen mode.
Displaying battery status in the modeline allows me to not have to
check it with the mouse.

#+begin_src emacs-lisp
  (use-package battery
    :config
    (setq battery-mode-line-format "[%b%p%%] "
          battery-load-low 20
          battery-load-critical 10)
    (display-battery-mode))
#+end_src

*** Display current time
:PROPERTIES:
:CUSTOM_ID: current_time
:END:

When I'm on my laptop I like to have Emacs in fullscreen mode.  Using
the built-in library to display time allows me to not have to use the
mouse to bring out the system status bar to check the time.

#+begin_src emacs-lisp
  (use-package time
    :config
    (setq display-time-format "%H:%M %d-%m-%Y"
          display-time-interval 60)
    (setq display-time-default-load-average nil)
    (display-time-mode))
#+end_src

** Line/column numbers and relevant indicators
:PROPERTIES:
:CUSTOM_ID: numbers_relevant_indicators
:END:

=jdp-whitespace.el= (shown after package configurations) has a simple
function to toggle =whitespace-mode=, which I use to check trailing
whitespace and indentation some times.  On that note, I also setup up
the =whitespace-cleanup-mode= package which is a minor mode that zaps
trailing whitespace when I save a buffer.

In addition to whitespace configuration, I also configure the
=diff-hl= package which shows changes in version controlled buffers on
the fringes of the window.

#+begin_src emacs-lisp
  (use-package diff-hl
    :ensure t
    :config
    (setq diff-hl-draw-borders nil)
    (global-diff-hl-mode))

  ;; Whitespace configuration
  (use-package jdp-whitespace
    :bind ([f6] . jdp-whitespace-space-toggle))

  (use-package whitespace-cleanup-mode
    :ensure t
    :config
    (global-whitespace-cleanup-mode))
#+end_src

Here is =jdp-whitespace.el=:

#+include: jdp-lisp/jdp-whitespace.el src emacs-lisp :tangle no

** Cursor and mouse settings
:PROPERTIES:
:CUSTOM_ID: cursor_mouse_settings
:END:

*** Cursor tweaks
:PROPERTIES:
:CUSTOM_ID: cursor_tweaks
:END:

By default, Emacs' cursor blinks constantly unless it has been
inactive for a small period of time.  I prefer to have it fixed and
not blink so I disable the blinking mode.

#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

*** Mouse wheel behaviour
:PROPERTIES:
:CUSTOM_ID: mouse_wheel
:END:

The value of =mouse-wheel-scroll-amount= indicates:

+ By default scroll one line at a time.
+ Scroll five lines at a time while holding Shift.
+ Scroll half a screen while holding Meta.

I also set some extra settings related to mouse scrolling.

#+begin_src emacs-lisp
  (use-package mouse
    :config
    (setq mouse-wheel-scroll-amount
          '(1
            ((shift) . 5)
            ((meta) . 0.5)
            ((control) . text-scale)))
    (setq mouse-wheel-progressive-speed nil
          mouse-wheel-follow-mouse t))
#+end_src

*** Scrolling behaviour
:PROPERTIES:
:CUSTOM_ID: scrolling_behaviour
:END:

By default Emacs repositions the point to the middle of the screen
after scrolling the page.  This creates some friction because we have
to be constantly guessing where the point has been repositioned.

#+begin_src emacs-lisp
  (setq scroll-margin 0
        scroll-conservatively 1000
        scroll-preserve-screen-position 'always)
#+end_src

*** Delete selection
:PROPERTIES:
:CUSTOM_ID: delete_selection
:END:

Very helpful mode.  It kills the marked region when you insert text
directly to it.  It has checks to ensure that yanking over a selected
region will not insert itself when =mouse-drag-copy-region= is in
effect.

#+begin_src emacs-lisp
  (use-package delsel
    :config
    (delete-selection-mode))
#+end_src

** Conveniences and minor extras
:PROPERTIES:
:CUSTOM_ID: conveniences_minor_extras
:END:

*** Auto revert mode
:PROPERTIES:
:CUSTOM_ID: auto_revert_mode
:END:

This mode updates the buffer whenever the file changes externally or
inside Emacs.

#+begin_src emacs-lisp
  (use-package autorevert
    :config
    (auto-revert-mode))
#+end_src

*** Preserve contents of system clipboard
:PROPERTIES:
:CUSTOM_ID: preserve_system_clipboard
:END:

Assume that you copy something outside of Emacs, then switch to Emacs
to paste it and before doing that, you notice something you want to
kill.  Doing that will place the last kill to the clipboard losing
what you copied initialy.  This is a nice solution to this problem:

#+begin_src emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+end_src

Now the clipboard contents are stored in the kill ring and can be
retrieved from there.

*** Pulse highlight changes (goggles)
:PROPERTIES:
:CUSTOM_ID: pulse_highlight
:END:

Goggles is a package developed by Daniel Mendler which pulses the area
where some change took place.

#+begin_src emacs-lisp
  (use-package goggles
    :ensure t
    :hook ((prog-mode text-mode) . goggles-mode)
    :config
    (setq-default goggles-pules t))
#+end_src

*** Newline characters for file ending
:PROPERTIES:
:CUSTOM_ID: newline_characters
:END:

=mode-require-final-newline= adds a newline character when visiting or
saving a buffer of relevance like a diff file.

#+begin_src emacs-lisp
  (setq mode-require-final-newline 'visit-save)
#+end_src

* Language settings for code and prose
:PROPERTIES:
:CUSTOM_ID: language_settings
:END:

This section deals with configurations and packages used for writing
with natural or programming languages.

** LSP-mode
:PROPERTIES:
:CUSTOM_ID: lsp-mode
:END:

The Language Server Protocol (LSP) is a protocol developed by
Microsoft and used between an editor/IDE and a language server that
provides features like auto-completion, go to definition, finding
references, etc.  This features used to be built-in in each editor in
the past but LSP has changed that.  Now with LSP the editor
communicates with a Language Server which provides all of the smart
features mentioned above.

=lsp-mode= is an Emacs client for the LSP protocol.  It provides a lot
of IDE features like code completion and code navigation for example
and provides optional integration with popular Emacs packages like
=company=, =flycheck= and =projectile= (I don't use this last one).

My =lsp-mode= configuration is pretty simple.  Apart from setting the
=lsp-keymap-prefix= variable I also add the =lsp-ui= package which
provides most of the UI aspects of =lsp-mode=.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :commands (lsp lsp-deferred)
    :hook (lsp-mode . lsp-enable-which-key-integration)
    :init (setq lsp-keymap-prefix "C-c l"))

  (use-package lsp-ui
    :ensure t
    :hook (lsp-mode . lsp-ui-mode)
    :config
    (setq lsp-ui-doc-position 'bottom
          lsp-ui-doc-show-with-mouse nil
          lsp-ui-doc-show-with-cursor nil))
#+end_src

** Programming languages support
:PROPERTIES:
:CUSTOM_ID: programming_languages_support
:END:

*** General settings
:PROPERTIES:
:CUSTOM_ID: general_settings
:END:

Here are some general configurations I want for =prog-mode=, that is,
in every programming language mode.  This settings include the
following:

+ Making URL's in comments and strings clickable.
+ Make comments autofill.
+ Highlight annotations like TODOs in source code (=hl-todo=).
+ Color code matching delimiters.

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'goto-address-prog-mode)

  (add-hook 'prog-mode-hook
            (lambda ()
              (setq-local comment-auto-fill-only-comments t)))

  (use-package hl-todo
    :hook (prog-mode . global-hl-todo-mode))

  (use-package rainbow-delimiters
    :ensure t
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** C
:PROPERTIES:
:CUSTOM_ID: c
:END:

Configurations for writing in C/C++.  These include the following:

+ Enabling =lsp-mode=.
+ Setting the default C writing style.

#+begin_src emacs-lisp
  (use-package cc-mode
    :hook (c-mode-common . lsp-deferred)
    :config
    (setq-default c-default-style "k&r"
                  c-basic-offset 4))
#+end_src

*** Elisp
:PROPERTIES:
:CUSTOM_ID: elisp
:END:

Macrostep is a package that allows us to expand macros to see what the
code is going to be interpreted as.  I use it a lot to check the
expansions of =use-package= in my Emacs configuration.

#+begin_src emacs-lisp
  (use-package macrostep
    :ensure t
    :bind (:map emacs-lisp-mode-map
                ("C-c e" . macrostep-expand)))
#+end_src

*** LaTeX
:PROPERTIES:
:CUSTOM_ID: latex
:END:

Latex is a typesetting system used to write academical and scientific
documents.  To use it you write a =.tex= source document that can be
compiled to diferent types of files (usually PDF files).  In the
source document you use commands starting with the =\= character to
tell the compiler how to format the text.

#+begin_src emacs-lisp
  (use-package tex
    :ensure auctex
    :hook (LaTeX-mode . turn-on-auto-fill)
    :config
    (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
    (add-hook 'TeX-after-compilation-finished-functions
              #'TeX-revert-document-buffer))
#+end_src

*** Python
:PROPERTIES:
:CUSTOM_ID: python
:END:

Configurations for writing in Python.  These include the following:

+ Setting the python interpreter to Python3.
+ Enabling =lsp-mode=.

#+begin_src emacs-lisp
  (setq python-shell-interpreter "python3")

  (use-package lsp-python-ms
    :init (setq lsp-python-ms-auto-install-server t)
    :hook (python-mode . lsp-deferred))
#+end_src

*** Shellscript
:PROPERTIES:
:CUSTOM_ID: shellscript
:END:

In this section I configure Emacs so that it makes any shellscript
file executable automatically after saving the file.

#+begin_src emacs-lisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Snippets
:PROPERTIES:
:CUSTOM_ID: snippets
:END:

Snippets are expandable templates that can be used to speed up the
process of coding.  Each snippet usually has a keyword which gets
expanded after pressing a particular key.  In Emacs' case, snippets
are covered by the package =yasnippet= and by default can be expanded
with the TAB key.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode))

  (use-package yasnippet-snippets
    :ensure t
    :after yasnippet)
#+end_src

** Configure 'electric' behaviour
:PROPERTIES:
:CUSTOM_ID: electric_behaviour
:END:

Emacs labels as "electric" any behaviour that involves auto-insertion
of characters contextually.  My settings are the following:

+ Indent automatically.
+ Insert closing quotes and brackets automatically.
+ Inserting a closing character will skip the existing one rather than
  adding one.  For example, typing =(= will insert =()= and then
  typing =)= will just be the same as moving forward a character.

#+begin_src emacs-lisp
  (use-package electric
    :config
    (electric-pair-mode)
    (electric-indent-mode))
#+end_src

** Parentheses (show-paren-mode)
:PROPERTIES:
:CUSTOM_ID: parentheses
:END:

Configuration for the mode that highlights matching delimiters or
parentheses.  It shows the matching delimiter/parentheses when it is
on the screen, otherwise it shows nothing.

#+begin_src emacs-lisp
  (use-package paren
    :config
    (setq show-paren-style 'parenthesis)
    (show-paren-mode))
#+end_src

** Tabs, indentation and the TAB key
:PROPERTIES:
:CUSTOM_ID: tabs_indentation
:END:

Here are my configurations for tabs and indentations.  Emacs tends to
mix tabs with spaces which can lead to misalignments.  As such, I
disable tabs by default.  In addition, I setup the TAB key so that it
first tries to indent the current line and then it tries to complete
the thing at point.

#+begin_src emacs-lisp
  (setq-default tab-width 4
                indent-tabs-mode nil
                tab-always-indent 'complete)
#+end_src

** Flycheck
:PROPERTIES:
:CUSTOM_ID: flycheck
:END:

Flycheck is a built-in linter interface.  It visualises in a buffer
what you would see on the command-line prompt or the compilation log
and marks the line where the note, warning or error is.

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :hook (prog-mode . global-flycheck-mode)
    :config
    (setq flycheck-display-errors-function
          #'flycheck-display-error-messages-unless-error-list))
#+end_src

** Eldoc
:PROPERTIES:
:CUSTOM_ID: eldoc
:END:

ElDoc is a minor mode that shows in the echo area the argument list of
the function call you are currently writing.  It was created for
writing elisp but it works with other languages like C, Perl, Python,
etc.  Also, if the point is on top of a variable eldoc will show its
documentation string.

#+begin_src emacs-lisp
  (use-package eldoc
    :config
    (global-eldoc-mode))
#+end_src

* History and state
:PROPERTIES:
:CUSTOM_ID: history_state
:END:

This section contains configurations for packages and options
dedicated to recording the state of various Emacs tools (history of
the minibuffer for example).

** Emacs server
:PROPERTIES:
:CUSTOM_ID: emacs_server
:END:

The following uses the first /running/ process of Emacs as a server
which other instances of Emacs can connect to.  This means that
calling =emacsclient= will share the same buffer list and data as the
original running process.  The server persists for as long as there is
an Emacs frame attached to it.

#+begin_src emacs-lisp
  (use-package server
    :config
    (add-hook 'after-init-hook
              (lambda ()
                (require 'server)
                (unless (server-running-p)
                  (server-start)))))
#+end_src

** Record diferent types of history
:PROPERTIES:
:CUSTOM_ID: types_of_history
:END:

*** Record cursor position
:PROPERTIES:
:CUSTOM_ID: cursor_position
:END:

Remember the position of the point in any given file.

#+begin_src emacs-lisp
  (use-package saveplace
    :config
    (setq save-place-file (locate-user-emacs-file "saveplace")
          save-place-forget-unreadable-files t)
    (save-place-mode))
#+end_src

*** Backup files
:PROPERTIES:
:CUSTOM_ID: backup_files
:END:

Here are some settings pertaining backup files.  I rarely use them but
every now and then you need them and in that scenario, they become
extremely useful.

#+begin_src emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name "backup/" user-emacs-directory))))
#+end_src

* System-specific settings
:PROPERTIES:
:CUSTOM_ID: system_settings
:END:

I use Emacs in Linux, macOS systems and Windows WSL.  There are
settings that I only want in some of these operating systems.  In this
section I configure this settings.

** macOS configurations
:PROPERTIES:
:CUSTOM_ID: macos_configurations
:END:

By default, on macOS Emacs uses the command key as the Super key and
the option key as the Meta key.  I believe this layout is inferior to
the one in a normal PC keyboard as I find that having the Meta key
right next to the spacebar is a better placement.  Therefore, I change
those keys so that they work like a traditional keyboard.

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq mac-command-modifier 'meta
          mac-option-modifier 'control))
#+end_src

** Windows WSL configurations
:PROPERTIES:
:CUSTOM_ID: wsl_configurations
:END:

WSL is the Windows Subsystem for Linux which allows us to have a Linux
kernel inside windows and use it as a terminal.  With the release of
WSL2 we can now use a X server to run GUI applications through WSL.
However, some extra settings have to be configured so that Emacs
behaves properly.

#+begin_src emacs-lisp
  (when (and (eq system-type 'gnu/linux) (getenv "WSLENV"))
    (let ((cmd-exe "/mnt/c/Windows/System32/cmd.exe")
	  (cmd-args '("/c" "start")))
      (when (file-exists-p cmd-exe)
	(setq browse-url-generic-program cmd-exe
	      browse-url-generic-args cmd-args
	      browse-url-browser-function 'browse-url-generic
	      search-web-default-browser 'browse-url-generic))))
#+end_src

* Other people's Emacs work
:PROPERTIES:
:CUSTOM_ID: other_people_emacs_work
:END:

Over the years the Emacs community has grown with new people that
catch their interest in this unique program.  As a program, one can
say that Emacs has extensibility as one of the, if not the, most
important core values.  Because of that, anyone that uses Emacs has
crafted or will end up crafting their own enviromment and workflow
through the use of this extensibility.  To help in this process, it
can be useful to check out the knowledge accumulated by the community
which can be found in custom Elisp code, videos or written tutorials
on particular workflows, and packages that cover a broad range of
needs.

Here is a non-exhaustive list of users that I have found to be helpful:

+ Protesilaos Stavrou :: Protesilaos' work in Emacs covers a broad
  range of themes, from switching to Emacs to the configuration of
  completion systems, buffer management, etc.  His content can be
  found in his [[https://protesilaos.com/dotemacs/][youtube channel]] and in his [[https://protesilaos.com/][website]].

+ Mike Zamansky :: Mike is a computer science professor who has been
  doing [[https://www.youtube.com/channel/UCxkMDXQ5qzYOgXPRnOBrp1w][videos on Emacs]] for several years.  There is a wealth of
  information to parse from those presentations as well as the
  corresponding [[https://github.com/zamansky/dot-emacs][dot-emacs code repository]].

+ System Crafters :: David Wilson's work on Emacs covers a broad range
  of themes, encapsulated in the [[https://github.com/daviwil/emacs-from-scratch][Emacs from scratch]] configuration. The
  [[https://www.youtube.com/c/SystemCrafters][Youtube channel]] contains lots of videos on how to set up and use all
  sorts of packages in Emacs, such as Org and the Mu4e email
  client. It is fair to say that if something is related to Emacs,
  David has either already done a video about it or is planning to do
  one in the near future. The [[https://systemcrafters.cc/][System Crafters]] website includes
  references to all such work, while it also covers contributions by
  the community that David has helped foster. The material on offer is
  top-notch. It serves as an excellent resource and point of reference
  for new and experienced users alike.
