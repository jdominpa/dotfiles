#+TITLE: Emacs Configuration
#+AUTHOR: Joan Domingo Pasarin
#+EMAIL: jdomingopasarin@icloud.com
#+OPTIONS: toc:nil num:nil

* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes
the initial setup for =package.el= and ensures that =use-package= is installed,
since I wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+begin_src emacs-lisp
    (require 'use-package-ensure)
    (setq use-package-always-ensure t)
#+end_src

Always compile packages, and use the newest version available.

#+begin_src emacs-lisp
    (use-package auto-compile
        :config (auto-compile-on-load-mode))

    (setq load-prefer-newer t)
#+end_src

* Use sensible-defaults.el

Use [[https://github.com/jdominpa/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+begin_src emacs-lisp
    (load-file "~/.emacs.d/sensible-defaults.el")
    (sensible-defaults/use-all-settings)
    (sensible-defaults/use-all-keybindings)
    (sensible-defaults/backup-to-temp-directory)
#+end_src

* Set personal information

#+begin_src emacs-lisp
    (setq user-full-name "Joan Domingo Pasarin"
        user-mail-address "jdomingopasarin@icloud.com"
        calendar-latitude 41.38
        calendar-longitude 2.15
        calendar-location-name "Barcelona")
#+end_src

* =evil-mode=

I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
usually not what I want. In particular, it makes working with Coq really
frustrating.

#+begin_src emacs-lisp
    (setq evil-want-abbrev-expand-on-insert-exit nil)
#+end_src

Load evil keybindings before starting evil (this option has to be set before
enabling evil mode).

#+begin_src emacs-lisp
    ;;(setq evil-want-keybinding nil)
#+end_src

Use =evil=.

#+begin_src emacs-lisp
    (use-package evil
        :init
        (setq evil-want-keybinding nil)

        :config
        (evil-mode 1))
#+end_src

Install =evil-collection=, which provides evil-friendly bindings for many modes.

#+begin_src emacs-lisp
    (use-package evil-collection
        :after evil)
#+end_src

Enable =surround= everywhere.

#+begin_src emacs-lisp
    (use-package evil-surround
        :config
        (global-evil-surround-mode 1))
#+end_src

Use =evil= with Org agendas.

#+begin_src emacs-lisp
    (use-package evil-org
        :after org
        :config
        (add-hook 'org-mode-hook 'evil-org-mode)
        (add-hook 'evil-org-mode-hook
                (lambda () (evil-org-set-key-theme)))
        (require 'evil-org-agenda)
        (evil-org-agenda-set-keys))
#+end_src

* Utility functions

Define a big ol' bunch of handy utility functions.

#+begin_src emacs-lisp
    (defun jdominpa/rename-file (new-name)
        (interactive "FNew name: ")
        (let ((filename (buffer-file-name)))
        (if filename
            (progn
                (when (buffer-modified-p)
                (save-buffer))
                (rename-file filename new-name t)
                (kill-buffer (current-buffer))
                (find-file new-name)
                (message "Renamed '%s' -> '%s'" filename new-name))
            (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

    (defun jdominpa/generate-scratch-buffer ()
        "Create and switch to a temporary scratch buffer with a random
        name."
        (interactive)
        (switch-to-buffer (make-temp-name "scratch-")))

    (defun jdominpa/kill-current-buffer ()
        "Kill the current buffer without prompting."
        (interactive)
        (kill-buffer (current-buffer)))

    (defun jdominpa/add-auto-mode (mode &rest patterns)
        "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
        (dolist (pattern patterns)
            (add-to-list 'auto-mode-alist (cons pattern mode))))

    (defun jdominpa/find-file-as-sudo ()
        (interactive)
        (let ((file-name (buffer-file-name)))
            (when file-name
                (find-alternate-file (concat "/sudo::" file-name)))))

    (defun jdominpa/region-or-word ()
        (if mark-active
            (buffer-substring-no-properties (region-beginning)
                                            (region-end))
            (thing-at-point 'word)))

    (defun jdominpa/append-to-path (path)
        "Add a path both to the $PATH variable and to Emacs' exec-path."
        (setenv "PATH" (concat (getenv "PATH") ":" path))
        (add-to-list 'exec-path path))

    (defun jdominpa/notify-send (title message)
        "Display a desktop notification by shelling out to `notify-send'."
        (call-process-shell-command
            (format "dunstify -t 2000 \"%s\" \"%s\"" title message)))
#+end_src

* UI preferences

** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+begin_src emacs-lisp
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
#+end_src

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+begin_src emacs-lisp
    (set-window-scroll-bars (minibuffer-window) nil nil)
#+end_src

The default frame title isn't useful. This binds it to the name of the current
project:

#+begin_src emacs-lisp
    (setq frame-title-format '((:eval (projectile-project-name))))
#+end_src
** Fringes

I don't like the little arrows shown when you can scroll down. This disables them

#+begin_src emacs-lisp :tangle yes
    (setq indicate-buffer-boundaries nil)
    (setq indicate-empty-lines nil)
#+end_src

** Use fancy lambdas

Why not?

#+begin_src emacs-lisp
    (global-prettify-symbols-mode t)
#+end_src

** Load up a theme

I'm currently using the "dracula" theme. I've got a scenic wallpaper, so
just a hint of transparency looks lovely and isn't distracting or hard to read.

#+begin_src emacs-lisp
    (use-package dracula-theme
        :config
        (let ((line (face-attribute 'mode-line :underline)))
            (set-face-attribute 'mode-line          nil :overline   line)
            (set-face-attribute 'mode-line-inactive nil :overline   line)
            (set-face-attribute 'mode-line-inactive nil :underline  line)
            (set-face-attribute 'mode-line          nil :box        nil)
            (set-face-attribute 'mode-line-inactive nil :box        nil)
            (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))

    (defun transparency (value)
        "Sets the transparency of the frame window. 0=transparent/100=opaque."
        (interactive "nTransparency Value 0 - 100 opaque:")
        (set-frame-parameter (selected-frame) 'alpha value))

    (defun jdominpa/apply-theme ()
        "Apply the `dracula' theme and make frames just slightly transparent."
        (interactive)
        (load-theme 'dracula t)
        (transparency 100))
#+end_src

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+begin_src emacs-lisp
    (if (daemonp)
        (add-hook 'after-make-frame-functions
                (lambda (frame)
                    (with-selected-frame frame (jdominpa/apply-theme))))
    (jdominpa/apply-theme))
#+end_src

** Use =doom-modeline= for a beautiful modeline

This gives me a truly lovely ribbon-based modeline.

#+begin_src emacs-lisp
    (use-package all-the-icons)
    (use-package doom-modeline
        :ensure t
        :init (doom-modeline-mode 1))
    (setq doom-modeline-major-mode-icon nil)
  ;;(use-package moody
  ;;    :config
  ;;    (setq x-underline-at-descent-line t)
  ;;    (moody-replace-mode-line-buffer-identification)
  ;;    (moody-replace-vc-mode))
#+end_src

** Use =minions= to hide all minor modes

I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

By default there's a =;-)= after the major mode; that's an adorable default, but
I'd rather skip it.

#+begin_src emacs-lisp
    (use-package minions
        :config
        (setq minions-mode-line-lighter ""
                minions-mode-line-delimiters '("" . ""))
        (minions-mode 1))
#+end_src

** Disable visual bell

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+begin_src emacs-lisp
    (setq ring-bell-function 'ignore)
#+end_src

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+begin_src emacs-lisp
    (setq scroll-conservatively 100)
#+end_src

** Set default font and configure font resizing

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+begin_src emacs-lisp
    (setq jdominpa/default-font "monospace")
    (setq jdominpa/default-font-size 13)
    (setq jdominpa/current-font-size jdominpa/default-font-size)

    (setq jdominpa/font-change-increment 1.1)

    (defun jdominpa/font-code ()
        "Return a string representing the current font (like \"Inconsolata-14\")."
        (concat jdominpa/default-font "-" (number-to-string jdominpa/current-font-size)))

    (defun jdominpa/set-font-size ()
        "Set the font to `jdominpa/default-font' at `jdominpa/current-font-size'.
        Set that for the current frame, and also make it the default for other, future frames."
        (let ((font-code (jdominpa/font-code)))
            (if (assoc 'font default-frame-alist)
                (setcdr (assoc 'font default-frame-alist) font-code)
            (add-to-list 'default-frame-alist (cons 'font font-code)))
            (set-frame-font font-code)))

    (defun jdominpa/reset-font-size ()
        "Change font size back to `jdominpa/default-font-size'."
        (interactive)
        (setq jdominpa/current-font-size jdominpa/default-font-size)
        (jdominpa/set-font-size))

    (defun jdominpa/increase-font-size ()
        "Increase current font size by a factor of `jdominpa/font-change-increment'."
        (interactive)
        (setq jdominpa/current-font-size
                (ceiling (* jdominpa/current-font-size jdominpa/font-change-increment)))
        (jdominpa/set-font-size))

    (defun jdominpa/decrease-font-size ()
        "Decrease current font size by a factor of `jdominpa/font-change-increment', down to a minimum size of 1."
        (interactive)
        (setq jdominpa/current-font-size
            (max 1
                (floor (/ jdominpa/current-font-size jdominpa/font-change-increment))))
        (jdominpa/set-font-size))

    (define-key global-map (kbd "C-)") 'jdominpa/reset-font-size)
    (define-key global-map (kbd "C-+") 'jdominpa/increase-font-size)
    (define-key global-map (kbd "C-=") 'jdominpa/increase-font-size)
    (define-key global-map (kbd "C-_") 'jdominpa/decrease-font-size)
    (define-key global-map (kbd "C--") 'jdominpa/decrease-font-size)

    (jdominpa/reset-font-size)
#+end_src

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+begin_src emacs-lisp
    (global-hl-line-mode)
#+end_src

** Disable cursor blink

   I don't like the cursor blinking constantly

   #+begin_src emacs-lisp
        (blink-cursor-mode 0)
   #+end_src

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+begin_src emacs-lisp
    (use-package diff-hl
        :config
        (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
        (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
#+end_src
** Disable parenthesis matching highlight

#+begin_src emacs-lisp
    (setq blink-matching-paren nil)
#+end_src
* Project management

  I use a few packages in virtually every programming or writing environment to
  manage the project, handle auto-completion, search for terms, and deal with
  version control. That's all in here.

** =ripgrep=

Install and configure [[https://github.com/Wilfred/deadgrep][deadgrep]] as an interface to =ripgrep=. I prefer =evil=
bindings.

#+begin_src emacs-lisp
    (use-package deadgrep
        :config (evil-collection-deadgrep-setup))
#+end_src
** =company=

Use =company-mode= everywhere.

#+begin_src emacs-lisp
    (use-package company
        :config
        (define-key company-mode-map (kbd "C-j") 'company-complete)
        (define-key company-active-map (kbd "C-n") 'company-select-next)
        (define-key company-active-map (kbd "C-p") 'company-select-previous))
    (add-hook 'after-init-hook 'global-company-mode)
#+end_src

Use =M-/= for completion.

#+begin_src emacs-lisp
    (global-set-key (kbd "M--") 'company-complete-common)
#+end_src

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
doesn't require any additional setup. I've bound its most useful command to
=M-.=.

#+begin_src emacs-lisp
    (use-package dumb-jump
        :config
        (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
        (setq dumb-jump-selector 'ivy))
#+end_src

** =flycheck=

#+begin_src emacs-lisp
    (use-package let-alist)
    (use-package flycheck)
#+end_src

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
    problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
    beyond 50 characters.
- On the command line I'll generally push a new branch with a plain old =git
    push=, which automatically creates a tracking branch on (usually) =origin=.
    Magit, by default, wants me to manually specify an upstream branch. This binds
    =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
    -v=. Convenient!
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
    (use-package magit
        :bind
        ("C-x g" . magit-status)

        :config
        (use-package evil-magit)
        (use-package with-editor)
        (setq magit-push-always-verify nil)
        (setq git-commit-summary-max-length 50)

        (with-eval-after-load 'magit-remote
            (transient-append-suffix 'magit-push ?P
                'magit-push-implicitly--desc
                'magit-push-implicitly ?p t))

        (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+end_src

I've been playing around with the newly-released =forge= for managing GitHub PRs
and issues. Seems slick so far.

#+begin_src emacs-lisp
    (use-package ghub)
    (use-package forge)
#+end_src

I'm also partial to =git-timemachine=, which lets you quickly page through the
history of a file.

#+begin_src emacs-lisp
    (use-package git-timemachine)
#+end_src

** =projectile=

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+begin_src emacs-lisp
    (use-package projectile
        :bind
        ("C-c v" . deadgrep)

        :config
        (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

        (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
        (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
        (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

        (setq projectile-completion-system 'ivy)
        (setq projectile-switch-project-action 'projectile-dired)
        (setq projectile-require-project-root nil))
#+end_src

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+begin_src emacs-lisp
    (use-package undo-tree)
#+end_src

* Programming environments

I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+begin_src emacs-lisp
    (setq-default tab-width 4)
#+end_src

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+begin_src emacs-lisp
    (use-package subword
        :config (global-subword-mode 1))
#+end_src

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+begin_src emacs-lisp
    (setq compilation-scroll-output t)
#+end_src

** Haskell

#+begin_src emacs-lisp
    (use-package haskell-mode)
#+end_src

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+begin_src emacs-lisp
    (add-hook 'haskell-mode-hook
        (lambda ()
            (haskell-doc-mode)
            (turn-on-haskell-indent)))
#+end_src

** Lisps

I like to use =paredit= in Lisp modes to balance parentheses (and more!).

#+begin_src emacs-lisp
  (use-package paredit)
#+end_src

=rainbow-delimiters= is convenient for coloring matching parentheses.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters)
#+end_src

All the lisps have some shared features, so we want to do the same things for
all of them. That includes using =paredit=, =rainbow-delimiters=, and
highlighting the whole expression when point is on a parenthesis.

#+begin_src emacs-lisp
    (setq lispy-mode-hooks
            '(clojure-mode-hook
                emacs-lisp-mode-hook
                lisp-mode-hook
                scheme-mode-hook))

    (dolist (hook lispy-mode-hooks)
        (add-hook hook (lambda ()
                            (setq show-paren-style 'expression)
                            (paredit-mode)
                            (rainbow-delimiters-mode))))
#+end_src

If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
documentation.

#+begin_src emacs-lisp
    (use-package eldoc
        :config
        (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+end_src

I also like using =flycheck-package= to ensure that my Elisp packages are
correctly formatted.

#+begin_src emacs-lisp
  (use-package flycheck-package)

  (eval-after-load 'flycheck
    '(flycheck-package-setup))
#+end_src

** =sh=

Indent with 2 spaces.

#+begin_src emacs-lisp
    (add-hook 'sh-mode-hook
        (lambda ()
            (setq sh-basic-offset 2
                sh-indentation 2)))
#+end_src
* Terminal

I use =multi-term= to manage my shell sessions. It's bound to =C-c t=.

#+begin_src emacs-lisp
    (use-package multi-term)
    (global-set-key (kbd "C-c t") 'multi-term)
#+end_src

I add a bunch of hooks to =term-mode=:

- I'd like links (URLs, etc) to be clickable.
- Yanking in =term-mode= doesn't quite work. The text from the paste appears in
the buffer but isn't sent to the shell process. This correctly binds =C-y= and
middle-click to yank the way we'd expect.
- I bind =M-o= to quickly change windows. I'd like that in terminals, too.
- I don't want to perform =yasnippet= expansion when tab-completing.

#+begin_src emacs-lisp
    (defun jdominpa/term-paste (&optional string)
        (interactive)
        (process-send-string
            (get-buffer-process (current-buffer))
            (if string string (current-kill 0))))

    (add-hook 'term-mode-hook
        (lambda ()
            (goto-address-mode)
            (define-key term-raw-map (kbd "c-y") 'jdominpa/term-paste)
            (define-key term-raw-map (kbd "<mouse-2>") 'jdominpa/term-paste)
            (define-key term-raw-map (kbd "m-o") 'other-window)
            (setq yas-dont-activate t)))
#+end_src
* Publishing and task management with Org-mode

I'd like the initial scratch buffer to be in Org:

#+begin_src emacs-lisp
    (setq initial-major-mode 'org-mode)
#+end_src

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+begin_src emacs-lisp
    (use-package org-bullets
        :init
        (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

Use syntax highlighting in source blocks while editing.

#+begin_src emacs-lisp
    (setq org-src-fontify-natively t)
#+end_src

Make TAB act as if it were issued in a buffer of the language's major mode.

#+begin_src emacs-lisp
    (setq org-src-tab-acts-natively t)
#+end_src

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+begin_src emacs-lisp
    (setq org-src-window-setup 'current-window)
#+end_src

Quickly insert a block of elisp:

#+begin_src emacs-lisp
    (add-to-list 'org-structure-template-alist
        '("el" . "src emacs-lisp"))
#+end_src

** Task and org-capture management

Store my org files in =~/Documents/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/Documents/org/archive.org=.

#+begin_src emacs-lisp
    (setq org-directory "~/Documents/org")
#+end_src

Record the time that a todo was archived.

#+begin_src emacs-lisp
    (setq org-log-done 'time)
#+end_src

Ensure that a task can't be marked as done if it contains unfinished subtasks or
checklist items. This is handy for organizing "blocking" tasks hierarchically.

#+begin_src emacs-lisp
    (setq org-enforce-todo-dependencies t)
    (setq org-enforce-todo-checkbox-dependencies t)
#+end_src

Default to two weeks of agenda (instead of the default single week). Begin those
weeks /today/, not on the last Monday.

#+begin_src emacs-lisp
    (setq org-agenda-span 14)
    (setq org-agenda-start-on-weekday nil)
#+end_src

Hide the category prefix from tasks. In practice, I've usually only got one or
two files of tasks, so prefixing tasks with the file they're stored in is mostly
redundant.
* Writing prose

** Enable spell-checking in the usual places

I want to make sure that I've enabled spell-checking if I'm editing text,
composing an email, or authoring a Git commit.

#+begin_src emacs-lisp
    (use-package flyspell
        :config
        (add-hook 'text-mode-hook 'turn-on-auto-fill)
        (add-hook 'gfm-mode-hook 'flyspell-mode)
        (add-hook 'org-mode-hook 'flyspell-mode)

        (add-hook 'git-commit-mode-hook 'flyspell-mode)
        (add-hook 'mu4e-compose-mode-hook 'flyspell-mode)

        (add-hook 'LaTeX-mode-hook 'flyspell-mode))
#+end_src

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+begin_src emacs-lisp
    (add-hook 'text-mode-hook 'auto-fill-mode)
    (add-hook 'gfm-mode-hook 'auto-fill-mode)
    (add-hook 'org-mode-hook 'auto-fill-mode)
    (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
#+end_src

** Spelling language

Set default spelling language to catalan.

#+begin_src emacs-lisp
    (setq ispell-dictionary "catalan")
#+end_src
* File management with =dired=

Hide dotfiles by default, but toggle their visibility with =.=.

#+begin_src emacs-lisp
    (use-package dired-hide-dotfiles
        :config
        (dired-hide-dotfiles-mode)
        (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
#+end_src

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

#+begin_src emacs-lisp
    (setq-default dired-listing-switches "-lhvA")
#+end_src

Set up DWIM ("do what I mean") for =dired=. When I've got two =dired= windows
side-by-side, and I move or copy files in one window, this sets the default
location to the other window.

#+begin_src emacs-lisp
    (setq dired-dwim-target t)
#+end_src

Kill buffers of files/directories that are deleted in =dired=.

#+begin_src emacs-lisp
    (setq dired-clean-up-buffers-too t)
#+end_src

Always copy directories recursively instead of asking every time.

#+begin_src emacs-lisp
    (setq dired-recursive-copies 'always)
#+end_src

Ask before recursively /deleting/ a directory, though.

#+begin_src emacs-lisp
    (setq dired-recursive-deletes 'top)
#+end_src

Files are normally moved and copied synchronously. This is fine for small or
local files, but copying a large file or moving a file across a mounted network
drive blocks Emacs until the process is completed. Unacceptable!

This uses =emacs-async= to make =dired= perform actions asynchronously.

#+begin_src emacs-lisp
    (use-package async
        :config
        (dired-async-mode 1))
#+end_src

Use "j" and "k" to move around in =dired=.

#+begin_src emacs-lisp
    (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
    (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
#+end_src

* Editing settings

** Save backups in =.emacs.d=

I store my backup files in =~/.emacs.d/backups= directory

#+begin_src emacs-lisp
    (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

** Quickly visit Emacs configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+begin_src emacs-lisp
    (defun jdominpa/visit-emacs-config ()
        (interactive)
        (find-file "~/.emacs.d/config.org"))

    (global-set-key (kbd "C-c e") 'jdominpa/visit-emacs-config)
#+end_src

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+begin_src emacs-lisp
    (global-set-key (kbd "C-x k") 'jdominpa/kill-current-buffer)
#+end_src

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+begin_src emacs-lisp
    (use-package helpful
        :init
        (global-set-key [remap describe-function] #'helpful-callable)
        (global-set-key [remap describe-variable] #'helpful-variable)
        (global-set-key [remap describe-command] #'helpful-command)
        (global-set-key [remap describe-symbol] #'helpful-symbol)
        (global-set-key [remap describe-key] #'helpful-key))

    (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window)
#+end_src

** Look for executables in =/usr/local/bin=

#+begin_src emacs-lisp
    (jdominpa/append-to-path "/usr/local/bin")
#+end_src

** Save my location within a file

Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+begin_src emacs-lisp
    (save-place-mode t)
#+end_src

** Always indent with spaces

Never use tabs. Tabs are the devilâ€™s whitespace.

#+begin_src emacs-lisp
    (setq-default indent-tabs-mode nil)
#+end_src

** Install and configure =which-key=

=which-key= displays the possible completions for a long keybinding. That's
really helpful for some modes (like =projectile=, for example).

#+begin_src emacs-lisp
    (use-package which-key
        :config (which-key-mode))
#+end_src

** Configure =ivy= and =counsel=

I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+begin_src emacs-lisp
    (use-package counsel
        :bind
        ("M-x" . 'counsel-M-x)
        ("C-s" . 'swiper)

        :config
        (use-package flx)
        (use-package smex)

        (ivy-mode 1)
        (setq ivy-use-virtual-buffers t)
        (setq ivy-count-format "(%d/%d) ")
        (setq ivy-initial-inputs-alist nil)
        (setq ivy-re-builders-alist
            '((swiper . ivy--regex-plus)
                (t . ivy--regex-fuzzy))))
#+end_src

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+begin_src emacs-lisp
    (defun jdominpa/split-window-below-and-switch ()
        "Split the window horizontally, then switch to the new pane."
        (interactive)
        (split-window-below)
        (balance-windows)
        (other-window 1))

    (defun jdominpa/split-window-right-and-switch ()
        "Split the window vertically, then switch to the new pane."
        (interactive)
        (split-window-right)
        (balance-windows)
        (other-window 1))

    (global-set-key (kbd "C-x 2") 'jdominpa/split-window-below-and-switch)
    (global-set-key (kbd "C-x 3") 'jdominpa/split-window-right-and-switch)
#+end_src

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+begin_src emacs-lisp
  (use-package wgrep)

  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+end_src

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/jdominpa/engine-mode][engine-mode]] and define a few useful engines.

#+begin_src emacs-lisp
    (use-package engine-mode)
    (require 'engine-mode)

    (defengine duckduckgo
        "https://duckduckgo.com/?q=%s"
        :keybinding "d")

    (defengine github
        "https://github.com/search?ref=simplesearch&q=%s"
        :keybinding "g")

    (defengine google
        "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

    (defengine stack-overflow
        "https://stackoverflow.com/search?q=%s"
        :keybinding "s")

    (defengine wikipedia
        "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
        :keybinding "w")

    (defengine youtube
        "https://www.youtube.com/results?search_query=%s"
        :keybinding "y")

    (engine-mode t)
#+end_src
* Set custom keybindings

Just a few handy functions.

#+begin_src emacs-lisp
    (global-set-key (kbd "M-o") 'other-window)
#+end_src
